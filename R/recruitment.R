#' Calculate recruitment pattern of lfq object
#'
#' \code{recruitment} calculates the recruitment pattern (i.e. monthly)
#' of an lfq object given corresponding \code{\link{VBGF}} parameters
#' and a defined length at recruitment (\code{Lrecr}, defaults to
#' \code{Lrecr = 0})
#' Time at recruitment \code{trecr} is calculated via a hindcast
#' using the \code{\link{calc_trecr}} function.
#'
#' This function does not represent a robust statistical method as it
#' assumes the same growth parameters for all individual counts
#' in the lfq count bins.
#' Nevertheless, the results should provide general information about
#' the recruitment pattern, e.g. relative recruitment strength by month.
#' Using the argument \code{use.rcounts = TRUE}, the analysis is
#' perfomed on restructured frequencies (positive values only).
#'
#' @param lfq a length-frequency object (i.e. class \code{lfq}) that contains
#' a \code{lfq$par} slot with \code{\link{VBGF}} parameters (usually fit
#' via \code{\link{ELEFAN}}, \code{\link{ELEFAN_GA}}, or \code{\link{ELEFAN_SA}}
#' functions).
#' @param Lrecr numeric. Length at recruitment
#' (default: \code{Lrecr = 0}).
#' @param tincr resolution to use for hindcasting time at recruitment
#' (default: \code{tincr = 0.01})
#' @param use.rcounts logical. Should restructured counts
#' (\code{lfq$rcounts}),
#' rather than raw catch counts (\code{lfq$catch}) be used to derive
#' recruitment pattern. If true, only bins with positive reconstructed counts
#' are considered, and those values are multiplied by 100 in order to provide
#' and appropriate scaling for density approxmations via
#' \code{\link[graphics]{hist}}.
#' @param plot logical. Should monthly recruitment pattern [\%] by plotted
#' as a \code{\link[graphics]{barplot}} (default: \code{plot = TRUE}).
#' @param hide.progressbar logical. Should progress bar be displayed
#' (default: \code{hide.progressbar = FALSE})
#' @param ... further arguments passed to
#' \code{link\[graphics]{barplot}} when \code{plot = TRUE}.
#'
#' @return object of "histogram" class containing
#' monthly recruitment pattern
#'
#' @details From Gayanilo et al (2005):
#' "The results generated by this routine should be treated
#' as approximations because, while allowing statements on
#' the number of annual pulses and on their relative strength,
#' this model is based on two assumptions that are rarely met
#' in reality: (i) all fish in the sample grow as described
#' by a single set of growth parameters...
#' When using restructured data, the temporal spread reduces
#' and thus probably better reflects the actual seasonality
#' of recruitment."
#'
#' Contrary to the method used in FiSAT, which produces either
#' a single or mixture of Gaussian distributions, the output
#' of this function is simply count data and corresponding densities
#' by month. Therefore it is possible to have densities for each
#' month, which is not the case in FiSAT.
#'
#' @export
#'
#' @examples
#'
#' # using catch frequencies
#' data("synLFQ4")
#' lfq <- synLFQ4
#' lfq$par <- list(
#'   Linf = 80, K = 0.5, t_anchor = 0.25, C = 0.75, ts = 0.5
#' )
#' tmp <- recruitment(lfq = lfq)
#'
#'
#' # using restructured frequencies
#' lfq <- lfqRestructure(synLFQ4, MA = 11)
#' lfq$par <- list(
#'   Linf = 80, K = 0.5, t_anchor = 0.25, C = 0.75, ts = 0.5
#' )
#' tmp <- recruitment(lfq = lfq, use.rcounts = TRUE)
#'
#'
#' # use of results in external plotting (via histogram())
#' plot(tmp, col = 5, freq = FALSE,
#'   main = "Recruitment pattern for synLFQ4",
#'   xlab = "Month"
#' )
#'
#'
#' # presentation as percentages
#' barplot(tmp$counts/sum(tmp$counts)*100, names.arg = month.abb,
#'   las = 2, ylab = "Recruitment [%]", main = "tmp")
#'
#'
#' # use of other Lrecr
#' data("alba")
#' lfq <- alba
#' lfq$par <- list(
#'   Linf = 9,5, K = 2.3, t_anchor = 0.28
#' )
#' lfq <- lfqRestructure(lfq, MA = 7)
#' plot(lfq)
#' tmp0 <- recruitment(lfq = lfq, Lrecr = 0, plot = FALSE)
#' tmp2 <- recruitment(lfq = lfq, Lrecr = 2, plot = FALSE)
#' op <- par(mfcol = c(2,1), mgp = c(2,0.5,0), mar = c(4,4,2,1))
#' plot(tmp0, col=8, freq=FALSE, main="Lrecr = 0", xlab="Month")
#' plot(tmp2, col=8, freq=FALSE, main="Lrecr = 2", xlab="Month")
#' par(op)
#'
#'
#'
#' @references
#' Brey, T., Soriano, M., Pauly, D., 1988. Electronic length frequency analysis. A
#' revised and expanded user's guide to ELEFAN 0, 1 and 2. (Second edition).
#' Berichte aus dem Institut f??r Meereskunde Kiel, No 177, 31p.
#'
#' Gayanilo, F. C., Sparre, P., & Pauly, D., 2005.
#' FAO-ICLARM stock assessment tools II: user's guide.
#' Rome: Worldfish Center,
#' Food and Agriculture Organization of the United Nations.
#'
#' Moreau, J., & Cuende, F. X., 1991. On improving the resolution of the recruitment
#' patterns of fishes. \emph{Fishbyte}, 9(1), 45-46.
#'
#' Pauly, D., 1982. Studying single-species dynamics in a tropical multispecies context.
#' In Theory and management of tropical fisheries. \emph{ICLARM Conference Proceedings}
#' (Vol. 9, No. 360, pp. 33-70).
#'
#' Sparre, P., Venema, S.C., 1998. Introduction to tropical fish stock assessment.
#' Part 1. Manual. \emph{FAO Fisheries Technical Paper}, (306.1, Rev. 2). 407 p.
#'
recruitment <- function(
  lfq,
  Lrecr = 0,
  tincr = 0.01,
  use.rcounts = FALSE,
  plot = TRUE,
  hide.progressbar = FALSE,
  ...
){
  if(use.rcounts & is.null(lfq$rcounts)){stop(
    "If use.rcounts = TRUE, then lfq$rcounts can not be empty.\n
    Please run lfqRestructure first and replace lfq with the output."
  )}
  trecr <- NaN * lfq$catch
  Lincl <- which(lfq$midLengths < lfq$par$Linf & lfq$midLengths > Lrecr)
  trecr <- trecr[Lincl,]
  counter_mat <- matrix(seq(length(trecr)), nrow = nrow(trecr), ncol = ncol(trecr), byrow = TRUE)
  if(!hide.progressbar){
    pb <- txtProgressBar(min=1, max=length(trecr), style=3)
  }
  for(i in seq(nrow(trecr))){
    for(j in seq(ncol(trecr))){
      trecr[i,j] <- calc_trecr(
        par = lfq$par,
        Lrecr = Lrecr,
        Lt = lfq$midLengths[i],
        t = lfq$dates[j],
        tincr = tincr
      )
        if(!hide.progressbar){
            setTxtProgressBar(pb, counter_mat[i,j])
        }
      
    }
  }
  if(!hide.progressbar){close(pb)}

  if(!use.rcounts){
    counts <- lfq$catch
  } else {
    counts <- round(lfq$rcounts*100)
    counts[which(counts<0)] <- 0
  }

  trecr <- rep(x = c(trecr), times=c(counts[Lincl,]))
  trecr <- trecr[!is.na(trecr)]
  trecr <- yeardec2date(trecr)
  trecr.mo <- as.numeric(format(trecr, "%m"))
  h <- hist(trecr.mo, breaks = seq(0.5, 12.5, by=1), plot = FALSE)
  if(plot){
    barplot(h$counts/sum(h$counts)*100, names.arg = month.abb,
      las = 2, ylab = "Recruitment [%]", ...)
  }
  return(h)
}
