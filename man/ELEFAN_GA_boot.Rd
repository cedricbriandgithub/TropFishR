% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bootstrapping.R
\name{ELEFAN_GA_boot}
\alias{ELEFAN_GA_boot}
\title{Bootstrapped ELEFAN_GA}
\usage{
ELEFAN_GA_boot(
  lfq,
  seasonalised = FALSE,
  low_par = NULL,
  up_par = NULL,
  parallel = TRUE,
  nresamp = 200,
  no_cores = detectCores() - 1,
  clusterType = "PSOCK",
  outfile = "output.txt",
  popSize = 60,
  maxiter = 50,
  run = 10,
  pmutation = 0.2,
  pcrossover = 0.8,
  elitism = base::max(1, round(popSize * 0.05)),
  MA = 5,
  addl.sqrt = FALSE,
  agemax = NULL,
  flagging.out = TRUE,
  seed = NULL,
  CI = 95
)
}
\arguments{
\item{lfq}{a length frequency object of the class `lfq`}

\item{seasonalised}{logical; indicating if the seasonalised von Bertalanffy
growth function should be applied (default: FALSE).}

\item{low_par}{a list providing the minimum of the search space in case
of real-valued or permutation encoded optimizations. When set to NULL the
following default values are used:
 \itemize{
  \item \strong{Linf} length infinity in cm (default is calculated from maximum
  length class in the data),
  \item \strong{K} curving coefficient (default: 0.01),
  \item \strong{t_anchor} time point anchoring growth curves in year-length
  coordinate system, corrsponds to peak spawning month (range: 0 to 1, default: 0),
  \item \strong{C} amplitude of growth oscillation (range: 0 to 1, default: 0),
  \item \strong{ts} summer point (ts = WP - 0.5) (range: 0 to 1, default: 0);
}}

\item{up_par}{a list providing the maximum of the search space in case of
real-valued or permutation encoded optimizations. When set to NULL the
following default values are used:
 \itemize{
  \item \strong{Linf} length infinity in cm (default is calculated from maximum
  length class in the data),
  \item \strong{K} curving coefficient (default: 1),
  \item \strong{t_anchor} time point anchoring growth curves in year-length
  coordinate system, corrsponds to peak spawning month (range: 0 to 1, default: 1),
  \item \strong{C} amplitude of growth oscillation (range: 0 to 1, default: 1),
  \item \strong{ts} summer point (ts = WP - 0.5) (range: 0 to 1, default: 1);
}}

\item{parallel}{logical; should parallelized computing be used. This differs from the
`parallel` argument in `ELEFAN_GA` in that it is not used within the `ga` function for
calculation at the population level, but rather for permutations. Depending on platform
operating system, the argument `clusterType` can be adjusted (see argument description for
details). (Default: `parallel = TRUE`)}

\item{nresamp}{numeric; the number of resamples (Default: `nresamp = 200`)}

\item{no_cores}{numeric (Default: `no_cores = detectCores() - 1`)}

\item{clusterType}{(Default: `clusterType = "PSOCK"`)}

\item{outfile}{character; text file name (Default: `outfile = "output.txt"`) which will
records the progress of the permutation completions.}

\item{popSize}{the population size. (Default: `popSize = 60`)}

\item{maxiter}{the maximum number of iterations to run before the GA search is halted.
(Default: `maxiter = 50`)}

\item{run}{the number of consecutive generations without any improvement
in the best fitness value before the GA is stopped. (Default: `run = 10`)}

\item{pmutation}{numeric. A small fraction of 1.0. The probability of mutation in a
parent chromosome. Usually mutation occurs with a small probability.
(Default: `pmutation = 0.2`)}

\item{pcrossover}{the probability of crossover between pairs of chromosomes.
Typically this is a large value.  (Default: `pcrossover = 0.8`)}

\item{elitism}{the number of best fitness individuals to survive at each generation.
By default the top 5\% individuals will survive at each iteration.}

\item{MA}{number indicating over how many length classes the moving average
should be performed (default: 5, for more information see \link{lfqRestructure})}

\item{addl.sqrt}{additional squareroot transformation of positive values
according to Brey et al. (1988) (default: FALSE, for
   more information see \link{lfqRestructure})}

\item{agemax}{maximum age of species; default NULL, then estimated from Linf}

\item{flagging.out}{logical; should positive peaks be flagged out? Original setting of
ELEFAN in TRUE. Default:TRUE}

\item{seed}{seed value for random number reproducibility (Default: NULL)}

\item{CI}{percentage for confidence intervals (Default: 95)}
}
\value{
an object of class 'lfqBoot' with following objects
   \itemize{
   \item \strong{bootRaw} a data.frame of fitted VBGF parameters (columns) by
              permutation (rows),
   \item \strong{bootModes} a dataframe with the modes of the VBGF parameters,
   \item \strong{bootCIs} a dataframe with the lower and upper 95% confidence
              interval for the VBGF growth parameters.
   }
}
\description{
`ELEFAN_GA_boot` performs a bootstrapped fitting of
  von Bertalanffy growth function (VBGF) via the \link{ELEFAN_GA} function. Most of the arguments
  are simply passed to the function within many permutations (resampling) of the original
  lfq data.
}
\examples{
# load data
data(alba)

# settings
MA <- 7
low_par <- list(Linf = 8, K = 0.1, t_anchor = 0, C = 0, ts = 0)
up_par <- list(Linf = 15, K = 5, t_anchor = 1, C = 1, ts = 1)
popSize <- 60
maxiter <- 50
run <- 10
pmutation <- 0.2
nresamp <- 20


# parallel version
library(parallel)
t1 <- Sys.time()
res <- ELEFAN_GA_boot(lfq=alba, MA = MA, seasonalised = FALSE,
  up_par = up_par, low_par = low_par,
  popSize = popSize, maxiter = maxiter, run = run, pmutation = pmutation,
  nresamp = nresamp, parallel = TRUE, no_cores = detectCores()-1,
  seed = 1
)
t2 <- Sys.time()
t2 - t1
res


# non-parallel version
t1 <- Sys.time()
res <- ELEFAN_GA_boot(lfq=alba, seasonalised = FALSE, up_par = up_par, low_par = low_par,
  popSize = popSize, maxiter = maxiter, run = run,
  pmutation = pmutation, nresamp = nresamp, MA=MA, parallel = FALSE,
  seed = 1
)
t2 <- Sys.time()
t2 - t1
res

# plot resulting distributions
op <- par(
  mfcol = c(1, ncol(res$bootRaw)-1),
  mar=c(1,2,2,1),
  mgp = c(2,0.5,0), tcl = -0.25, cex=1
)
for(i in seq(ncol(res$bootRaw)-1)){
  boxplot(res$bootRaw[[i]], boxwex = 0.25, col = 8)
  text(1, median(res$bootRaw[[i]]), labels = round(median(res$bootRaw[[i]]),2),
    pos = 4, col = 4)
  mtext(names(res$bootRaw)[i], line=0.25, side=3)
}
par(op)

}
